:javascript
  class CocMap {
    constructor({ elementId, shapes, metrics, colors, max_rate, max_count }) {
      this.initInfoBox = this.initInfoBox.bind(this);
      this.style = this.style.bind(this);
      this.updateInfo = this.updateInfo.bind(this);
      this.clearInfo = this.clearInfo.bind(this);
      this.onEachFeature = this.onEachFeature.bind(this);
      this.updateMetrics = this.updateMetrics.bind(this);
      this.elementId = elementId;
      this.shapes = shapes;
      this.colors = colors;
      this.metrics = metrics;
      this.max_rate = max_rate;
      this.max_count = max_count;
      this.showingData = false;

      const mapOptions = {
        minZoom: 5,
        maxZoom: 9,
        zoomSnap: 0.2,
        zoomControl: false,
        scrollWheelZoom: false,
      };
      this.strokeColor = '#aaa';

      this.highlightedFeatures = [];

      this.map = new L.Map(this.elementId, mapOptions);
      this.markers = L.layerGroup().addTo(this.map);

      L.control
        .zoom({
          position: 'bottomleft',
        })
        .addTo(this.map);

      // Do not show basemap
      // osmUrl = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'
      // osmAttrib = 'Map data Â© <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
      // osm = new L.TileLayer(osmUrl, {attribution: osmAttrib})
      // @map.addLayer(osm)

      const geoJSONOptions = {
        style: this.style,
        onEachFeature: this.onEachFeature,
      };

      this.geojson = L.geoJSON(this.shapes, geoJSONOptions).addTo(this.map);

      this.map.fitBounds(this.geojson.getBounds());
      this.map.createPane('markers');

      this.initInfoBox();
    }

    initInfoBox() {
      this.info = L.control();
      this.info.update = (props) => {
        let innerHTML = '';
        let hidden = true;
        if (props != null) {
          const { id, name, code, metric } = props;
          const rate = this.metrics[name].rate
          const count = this.metrics[name].count
          const population = this.metrics[name].overall_population
          innerHTML = `<h4>Zip Code: ${name}</h4><div class="rate">${rate} per 10,000 people</div><div class="count">${count.toLocaleString()} clients of ${population.toLocaleString()} people</div>`;

          hidden = false;
        }
        this._div.innerHTML = innerHTML;
        this._div.hidden = hidden;
      };

      this.info.onAdd = () => {
        this._div = L.DomUtil.create('div', 'l-info');
        this.info.update();
        return this._div;
      };

      return this.info.addTo(this.map);
    }

    style() {
      return {
        fillColor: 'white',
        weight: 2,
        opacity: 1,
        color: this.strokeColor,
        dashArray: '',
        fillOpacity: 0.8,
      };
    }

    getColor(rate) {
      let division_size = this.max_rate / this.colors.length
      let division = Math.floor(rate / division_size)
      if(division == 0) {
        if(rate > 0) {
          return this.colors[1]
        } else {
          return this.colors[0]
        }
      } else if(division < this.colors.length) {
        return this.colors[division]
      } else {
        return this.colors[this.colors.length]
      }
    }

    getSize(count) {
      let size = Math.round(count / this.max_count * 20)
      return size
    }

    bringLayerToFront(layer) {
      if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
        return layer.bringToFront();
      }
    }

    bringLayerToBack(layer) {
      if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
        return layer.bringToBack();
      }
    }

    getLayerById(id) {
      return this.geojson.getLayers().find((l) => l.feature.properties.id == id);
    }

    updateInfo(e) {
      const layer = (e != null ? e.target : undefined) || e;
      if (this.info != null) {
        this.info.update(layer.feature.properties);
      }
      this.bringLayerToFront(layer);
      // layer.setStyle({
      //   color: '#888',
      //   weight: 3,
      //   opacity: 1,
      // });
    }

    clearInfo(e) {
      const layer = (e != null ? e.target : undefined) || e;
      if (this.info != null) {
        this.info.update(null);
      }
      if (layer.feature.properties.id != this.secondaryId) {
        this.bringLayerToBack(layer);
        // return layer.setStyle({
        //   color: this.strokeColor,
        //   weight: 1,
        //  opacity: 1,
        // });
      }
    }

    onEachFeature(feature, layer) {
      const handlers = {
        mouseover: this.updateInfo,
        mouseout: this.clearInfo,
      };
      return layer.on(handlers);
    }

    updateMetrics(metrics) {
      this.markers.clearLayers();

      this.metrics = metrics
      this.geojson.getLayers().forEach((l) => {
        const zip = l.feature.properties.name;
        l.feature.properties.metric = this.metrics[zip].rate;
        this.geojson.resetStyle(l);
        let count = this.metrics[zip].count
        if(count > 0) {
          let marker = L.circleMarker(l.feature.properties.centroid, {
            pane: 'markers',
            radius: this.getSize(count),
            fillColor: this.getColor(l.feature.properties.metric),
            weight: 1,
            opacity: 0.8,
            fillOpacity: 0.8,
            stroke: false,
            // feature: l.feature,
          });
          marker.feature = l.feature;
          marker.on('mouseover', this.updateInfo);
          marker.on('mouseout', this.clearInfo);
          marker.addTo(this.markers);

        }
        // return l.setStyle({
        //   fillColor: this.getColor(l.feature.properties.metric),
        //   fillOpacity: 1,
        // });
      });
    }
  };
