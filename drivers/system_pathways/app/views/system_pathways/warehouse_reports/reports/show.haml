#sankey
- content_for :page_js do
  :javascript


    const d3Sankey = d3
    let data = [
      // System -> ES
      {
        "source": "Served by Homeless System",
        "target": "ES/SH",
        "value": 124,
      },
      // ES -> Destinations (Non-Permanent)
      {
        "source": "ES/SH",
        "target": "Institutional Destinations",
        "value": 9,
      },
      {
        "source": "ES/SH",
        "target": "Temporary Destinations",
        "value": 8
      },
      {
        "source": "ES/SH",
        "target": "Unknown/Other",
        "value": 18
      },
      {
        "source": "ES/SH",
        "target": "Homeless",
        "value": 20
      },
      // ES -> Other types
      {
        "source": "ES/SH",
        "target": "RRH",
        "value": 23
      },
      {
        "source": "ES/SH",
        "target": "PSH",
        "value": 3
      },
      {
        "source": "ES/SH",
        "target": "TH",
        "value": 4
      },
      // Remaining types from system
      {
        "source": "Served by Homeless System",
        "target": "RRH",
        "value": 12
      },
      {
        "source": "Served by Homeless System",
        "target": "PSH",
        "value": 28
      },
      {
        "source": "Served by Homeless System",
        "target": "TH",
        "value": 50
      },
      {
        "source": "Served by Homeless System",
        "target": "Other Pathways",
        "value": 8
      },
      // TH -> RRH
      {
        "source": "TH",
        "target": "RRH",
        "value": 5
      },
      // TH -> PSH
      {
        "source": "TH",
        "target": "PSH",
        "value": 3
      },
      // RRH -> PSH
      {
        "source": "RRH",
        "target": "PSH",
        "value": 2
      },
      // RRH to destinations
      {
        "source": "RRH",
        "target": "Institutional Destinations",
        "value": 4
      },
      {
        "source": "RRH",
        "target": "Temporary Destinations",
        "value": 6
      },
      {
        "source": "RRH",
        "target": "Unknown/Other",
        "value": 12
      },
      {
        "source": "RRH",
        "target": "Homeless",
        "value": 2
      },
      {
        "source": "RRH",
        "target": "Permanent Destinations",
        "value": 32
      },
      // PSH to destinations
      {
        "source": "PSH",
        "target": "Homeless",
        "value": 0
      },
      {
        "source": "PSH",
        "target": "Unknown/Other",
        "value": 5
      },
      {
        "source": "PSH",
        "target": "Permanent Destinations",
        "value": 8
      },

      // TH to destinations
      {
        "source": "TH",
        "target": "Temporary Destinations",
        "value": 5
      },
      {
        "source": "TH",
        "target": "Permanent Destinations",
        "value": 15
      },
      // other pathways to destinations
      {
        "source": "Other Pathways",
        "target": "Permanent Destinations",
        "value": 8,
      },

      // returns
      {
        "source": "Permanent Destinations",
        "target": "Returns to Homelessness",
        "value": 4
      },
      // ES -> Permanent destinations
      {
        "source": "ES/SH",
        "target": "Permanent Destinations",
        "value": 32
      },

    ];
    const targetColors = {
      "ES/SH": '#85B5B2',
      "Institutional Destinations": '#808080',
      "Temporary Destinations": '#808080',
      "Unknown/Other": '#808080',
      "Homeless": '#808080',
      "Returns": '#967762',
      "RRH": '#D1605E',
      "TH": '#A77C9F',
      "PSH": '#E7CA60',
      "Other Pathways": '#E49344',
      "Permanent Destinations": '#6A9F58',
    }

    const nodeWeights = {
      "ES/SH": -1,
      "RRH": 0,
      "PSH": 11,
      "TH": 2,
      "Other Pathways": 5,
      "Homeless": 3,
      "Unknown/Other": 4,
      "Temporary Destinations": 5,
      "Institutional Destinations": 6,
      "Permanent Destinations": 10,
    }

    let options = {
      nodeGroup: d => d.id.split(/\W/)[0], // take first word for color
      // nodeAlign, // e.g., d3.sankeyJustify; set by input above
      // linkColor, // e.g., "source" or "target"; set by input above
      targetColors: targetColors,
      nodeWeights: nodeWeights,
      width: 1200,
      height: 400,
    }
    let sankeyChart = new App.D3Chart.Sankey('#sankey', options);
    sankeyChart.prepare();
    sankeyChart.draw(data);

    /*
    function SankeyChart({
      nodes, // an iterable of node objects (typically [{id}, …]); implied by links if missing
      links // an iterable of link objects (typically [{source, target}, …])
    }, {
      format = ",", // a function or format specifier for values in titles
      align = "justify", // convenience shorthand for nodeAlign
      nodeId = d => d.id, // given d in nodes, returns a unique identifier (string)
      nodeGroup, // given d in nodes, returns an (ordinal) value for color
      nodeGroups, // an array of ordinal values representing the node groups
      nodeLabel, // given d in (computed) nodes, text to label the associated rect
      nodeTitle = d => `${d.id}\n${format(d.value)}`, // given d in (computed) nodes, hover text
      nodeAlign = align, // Sankey node alignment strategy: left, right, justify, center
      nodeWidth = 100, // width of node rects
      nodePadding = 20, // vertical separation between adjacent nodes
      nodeLabelPadding = -80, // horizontal separation between node and label
      nodeStroke = "currentColor", // stroke around node rects
      nodeStrokeWidth = 0, // width of stroke around node rects, in pixels
      nodeStrokeOpacity, // opacity of stroke around node rects
      nodeStrokeLinejoin, // line join for stroke around node rects
      linkSource = ({source}) => source, // given d in links, returns a node identifier string
      linkTarget = ({target}) => target, // given d in links, returns a node identifier string
      linkValue = ({value}) => value, // given d in links, returns the quantitative value
      targetColors = {},
      linkPath = d3Sankey.sankeyLinkHorizontal(), // given d in (computed) links, returns the SVG path
      linkTitle = d => `${d.source.id} → ${d.target.id}\n${format(d.value)}`, // given d in (computed) links
      linkColor = "source-target", // source, target, source-target, or static color
      linkStrokeOpacity = 0.5, // link stroke opacity
      linkMixBlendMode = "multiply", // link blending mode
      colors = d3.schemeTableau10, // array of colors
      width = 640, // outer width, in pixels
      height = 400, // outer height, in pixels
      marginTop = 5, // top margin, in pixels
      marginRight = 1, // right margin, in pixels
      marginBottom = 5, // bottom margin, in pixels
      marginLeft = 1, // left margin, in pixels
    } = {}) {
      // Convert nodeAlign from a name to a function (since d3-sankey is not part of core d3).
      if (typeof nodeAlign !== "function") nodeAlign = {
        left: d3Sankey.sankeyLeft,
        right: d3Sankey.sankeyRight,
        center: d3Sankey.sankeyCenter
      }[nodeAlign] ?? d3Sankey.sankeyJustify;

      // Compute values.
      const LS = d3.map(links, linkSource).map(intern);
      const LT = d3.map(links, linkTarget).map(intern);
      const LV = d3.map(links, linkValue);
      if (nodes === undefined) nodes = Array.from(d3.union(LS, LT), id => ({id}));
      const N = d3.map(nodes, nodeId).map(intern);
      const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern);

      // Replace the input nodes and links with mutable objects for the simulation.
      nodes = d3.map(nodes, (_, i) => ({id: N[i]}));
      links = d3.map(links, (_, i) => ({source: LS[i], target: LT[i], value: LV[i]}));

      // Ignore a group-based linkColor option if no groups are specified.
      if (!G && ["source", "target", "source-target"].includes(linkColor)) linkColor = "currrentColor";

      // Compute default domains.
      if (G && nodeGroups === undefined) nodeGroups = G;

      // Construct the scales.
      const color = nodeGroup == null ? null : d3.scaleOrdinal(nodeGroups, colors);

      // Compute the Sankey layout.
      let sankey = d3Sankey.sankey()
        .nodeId(({index: i}) => N[i])
        .nodeAlign(nodeAlign)
        .nodeWidth(nodeWidth)
        .nodePadding(nodePadding)
        .nodeSort(node_sorter)
        .extent([[marginLeft, marginTop], [width - marginRight, height - marginBottom]])
      sankey({nodes, links});

      // Compute titles and labels using layout nodes, so as to access aggregate values.
      if (typeof format !== "function") format = d3.format(format);
      const Tl = nodeLabel === undefined ? N : nodeLabel == null ? null : d3.map(nodes, nodeLabel);
      const Tt = nodeTitle == null ? null : d3.map(nodes, nodeTitle);
      const Lt = linkTitle == null ? null : d3.map(links, linkTitle);

      // A unique identifier for clip paths (to avoid conflicts).
      const uid = `O-${Math.random().toString(16).slice(2)}`;

      const svg = d3.create("svg")
        //.attr("width", width)
        //.attr("height", height)
        .attr("viewBox", `0 0 ${width} ${height}`)
        .attr("viewBox", [0, 0, width, height])
        .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

      const node = svg.append("g")
        .attr("stroke", nodeStroke)
        .attr("stroke-width", nodeStrokeWidth)
        .attr("stroke-opacity", nodeStrokeOpacity)
        .attr("stroke-linejoin", nodeStrokeLinejoin)
        .selectAll("rect")
        .data(nodes)
        .join("rect")
        .attr("x", d => d.x0)
        .attr("y", d => {
          d = tranlate_location(d)
          return d.y0
        })
        .attr("height", d => d.y1 - d.y0)
        .attr("width", d => d.x1 - d.x0);

      if (G) node.attr("fill", ({index: i}) => color_for_target(G[i]))
      if (Tt) node.append("title").text(({index: i}) => Tt[i]);
      let return_link = links.find(link => link.target.id == 'Returns to Homelessness')
      if(return_link) {
        return_link.y1 = height - 50
      }
      const link = svg.append("g")
          .attr("fill", "none")
          .attr("stroke-opacity", linkStrokeOpacity)
        .selectAll("g")
        .data(links)
        .join("g")
          .style("mix-blend-mode", linkMixBlendMode);
            if (linkColor === "source-target") link.append("linearGradient")
        .attr("id", d => `${uid}-link-${d.index}`)
        .attr("gradientUnits", "userSpaceOnUse")
        .attr("x1", d => d.source.x1)
        .attr("x2", d => d.target.x0)
        .call(gradient => gradient.append("stop")
          .attr("offset", "0%")
          .attr("stop-color", ({source: {index: i}}) => color_for_target(G[i])))
        .call(gradient => gradient.append("stop")
          .attr("offset", "100%")
          .attr("stop-color", ({target: {index: i}}) => color_for_target(G[i])));
      // Target specific node and link
      // move it
      // d3.select(‘#id’).node().__datum___
      link.append("path")
        .attr("d", linkPath)
        .attr("stroke", linkColor === "source-target" ? ({index: i}) => 'url(#' + uid + '-link-' + i + ')'
          : linkColor === "source" ? ({source: {index: i}}) => color(G[i])
          : linkColor === "target" ? ({target: {index: i}}) => color(G[i])
          : linkColor)
        .attr("stroke-width", ({width}) => Math.max(1, width))
        .call(Lt ? path => path.append("title").text(({index: i}) => Lt[i]) : () => {});

      // Text
      if (Tl) svg.append("g")
          .attr("font-family", "sans-serif")
          .attr("font-size", 14)
        .selectAll("text")
        .data(nodes)
        .join("text")
          .attr("x", d => d.x0 < width / 2 ? d.x1 + nodeLabelPadding : d.x0 - nodeLabelPadding)
          .attr("y", d => (d.y1 + d.y0) / 2)
          .attr("dy", "0.35em")
          .attr("text-anchor", d => d.x0 < width / 2 ? "start" : "end")
          //.attr("transform", "rotate(90)")
          .attr("style", "font-weight:600;fill:black;stroke:white;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:0.5;")
          .html(({index: i}) => {
            //let words = [];
            //Tl[i].split(/\b/).forEach(item => words.push('<tspan dx="0" dy="1.2em">' + item + '</tspan>'))
            //console.log(words.josvin(''))
            return Tl[i]
          });

      function intern(value) {
        return value !== null && typeof value === "object" ? value.valueOf() : value;
      }

      function color_for_target(id) {
        return targetColors[id] == null ? color(id) : targetColors[id]
      }

      function tranlate_location(d) {
        if(d.id == 'Returns to Homelessness') {
          let diff = d.y1 - d.y0
          d.y0 = height - 50 - diff * .5
          d.y1 = height - 50 + diff * .5
        } else {
          d.y0
        }
        return d
      }

      function node_sorter(a, b) {
        a_weight = nodeWeights[a.id] || 0
        b_weight = nodeWeights[b.id] || 0
        return a_weight > b_weight
      }

      return Object.assign(svg.node(), {scales: {color}});
    };

    const nodeAlign = 'left'; //"justify";
    const linkColor = 'source-target';

    let chart = SankeyChart({
      links: data
    }, {
      nodeGroup: d => d.id.split(/\W/)[0], // take first word for color
      nodeAlign, // e.g., d3.sankeyJustify; set by input above
      linkColor, // e.g., "source" or "target"; set by input above
      targetColors: targetColors,
      format: (f => d => `${f(d)} TWh`)(d3.format(",.1~f")),
      width: 1200, //width,
      height: 600
    });
    // return_link = links.find(link => link.target == 'Returns to Homelessness')
    // console.log(links, return_link, return_link.index)nodeGroup
    document.getElementById('sankey').appendChild(chart);

    // Tooltips: https://d3-graph-gallery.com/graph/interactivity_tooltip.html
    // https://gramener.github.io/d3js-playbook/tooltips.html
    // https://www.d3sankey.com/tooltips
    */
